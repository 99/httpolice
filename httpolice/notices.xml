<?xml version="1.0" encoding="utf-8"?>

<notices>

  <error id="1000">
    <title>Malformed <ref to="header"/> header</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1001">
    <title>Final <ref to="msg.headers.transfer_encoding"/> is not <tc>chunked</tc></title>
    <rfc num="7230" sect="3.3.1">
      If any transfer coding
   other than <tc>chunked</tc> is applied to a request payload body, the sender
   MUST apply <tc>chunked</tc> as the final transfer coding to ensure that the
   message is properly framed.
    </rfc>
  </error>

  <error id="1002">
    <title><ref to="msg.headers.transfer_encoding"/> contains <tc>chunked</tc> more than once</title>
    <rfc num="7230" sect="3.3.1">
      A sender MUST
   NOT apply <tc>chunked</tc> more than once to a message body (i.e., chunking an
   already chunked message is not allowed).
    </rfc>
  </error>

  <internal id="1003">
    <title>Not decoding <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> transfer coding. (This doesn’t mean that it’s wrong.)</explain>
  </internal>

  <error id="1004">
    <title>Incomplete message according to <ref to="msg.headers.content_length"/></title>
    <explain>This message’s <ref to="msg.headers.content_length"/> header indicates that the body is <ref to="msg.headers.content_length.value"/> bytes long, but there are fewer bytes remaining on the stream.</explain>
  </error>

  <error id="1005">
    <title>Malformed <ref to="msg.headers.transfer_encoding"/>: <tc>chunked</tc></title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1006">
    <title>Malformed request heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <internal id="1007">
    <title>Stop parsing request stream due to errors</title>
    <explain>Due to previous errors, the request stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </internal>

  <error id="1008">
    <title>Not enough requests for this response</title>
    <explain>If HTTPolice is parsing things correctly, it seems that there is no request corresponding to this response. HTTPolice will check this response in isolation.</explain>
  </error>

  <error id="1009">
    <title>Malformed response heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <internal id="1010">
    <title>Stop parsing response stream due to errors</title>
    <explain>Due to previous errors, the response stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </internal>

  <internal id="1011">
    <title>Stop parsing response stream after switching protocols</title>
    <explain>The response status code <ref to="msg.status"/> indicates that the connection has switched to a different protocol. HTTPolice will not parse the remainder of the response stream.</explain>
  </internal>

  <internal id="1012">
    <title>Stop parsing response stream after switching to a tunnel</title>
    <explain>A <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request indicates that the connection has switched to being a tunnel. HTTPolice will not parse the remainder of the response stream.</explain>
  </internal>

  <error id="1013">
    <title><ref to="entries">Multiple</ref> <ref to="header"/> headers</title>
    <rfc num="7230" sect="3.2.2">
      A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
    </rfc>
  </error>

  <comment id="1014">
    <title>RWS is not a single space in <ref to="place"/></title>
    <explain>The specification for <ref to="place"/> includes the rule named RWS. It should be generated by senders as just a single space, but here it was <ref to="num"/> characters. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </comment>

  <warning id="1015">
    <title>Bad whitespace (BWS) in <ref to="place"/></title>
    <explain>The specification for <ref to="place"/> includes the rule named BWS, which is whitespace allowed for historical reasons; current implementations must omit it. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </warning>

  <warning id="1016">
    <title>Obsolete line folding in header fields</title>
    <explain>This message uses line folding (the ‘obs-fold’ rule) to split one header field over several physical lines, but this is deprecated and prohibited in most contexts. See <rfc num="7230" sect="3.2.4"/>.</explain>
  </warning>

  <comment id="1017">
    <title>Superfluous escaping in <ref to="place"/></title>
    <explain>This message uses the ‘quoted-pair’ rule to escape the character <ref to="char"/> in a context where this escaping is unnecessary and should not be used. See <rfc num="7230" sect="3.2.6"/>.</explain>
    <explain>If a literal backslash \ was intended here, it should itself be escaped as \\.</explain>
  </comment>

  <error id="1018">
    <title><ref to="msg.headers.transfer_encoding"/> header in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).
    </rfc>
  </error>

  <error id="1019">
    <title><ref to="msg.headers.transfer_encoding"/> header in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in
   any 2xx (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <error id="1020">
    <title>Message with both <ref to="msg.headers.transfer_encoding"/> and <ref to="msg.headers.content_length"/></title>
    <rfc num="7230" sect="3.3.2">
      A sender MUST NOT send a <h>Content-Length</h> header field in any message
   that contains a <h>Transfer-Encoding</h> header field.
    </rfc>
  </error>

  <comment id="1021">
    <title><ref to="msg.method"/> request with no <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD send a <h>Content-Length</h> in a request message when
   no <h>Transfer-Encoding</h> is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a <m>POST</m> request even when the value is 0
   (indicating an empty payload body).
    </rfc>
  </comment>

  <comment id="1022">
    <title><ref to="msg.method"/> request with <ref to="msg.headers.content_length"/> but no body</title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD NOT send a
   <h>Content-Length</h> header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.
    </rfc>
  </comment>

  <error id="1023">
    <title><ref to="msg.headers.content_length"/> header in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.2">
      A server MUST NOT send a <h>Content-Length</h> header field in any response
   with a status code of 1xx (Informational) or <st>204</st> (No Content).
    </rfc>
  </error>

  <error id="1024">
    <title><ref to="msg.headers.content_length"/> header in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.2">
      A
   server MUST NOT send a <h>Content-Length</h> header field in any 2xx
   (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <comment id="1025">
    <title>Response delimited only by closing the connection</title>
    <explain>This response includes no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <rfc num="7230" sect="3.3.3">
      Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
    </rfc>
  </comment>

  <error id="1026">
    <title><ref to="header"/> in a trailer</title>
    <rfc num="7230" sect="4.1.2">
      A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., <h>Transfer-Encoding</h> and <h>Content-Length</h>),
   routing (e.g., <h>Host</h>), request modifiers (e.g., controls and
   conditionals in Section 5 of [RFC7231]), authentication (e.g., see
   [RFC7235] and [RFC6265]), response control data (e.g., see Section
   7.1 of [RFC7231]), or determining how to process the payload (e.g.,
   <h>Content-Encoding</h>, <h>Content-Type</h>, <h>Content-Range</h>, and <h>Trailer</h>).
    </rfc>
  </error>

  <error id="1027">
    <title>Could not decode <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1028">
    <title><ref to="msg.headers.te"/>: <tc>chunked</tc></title>
    <rfc num="7230" sect="4.3">
      A client MUST NOT send
   the <tc>chunked</tc> transfer coding name in <h>TE</h>; chunked is always acceptable
   for HTTP/1.1 recipients.
    </rfc>
  </error>

  <error id="1029">
    <title><ref to="msg.headers.te"/> without “<ref to="msg.headers.connection"/>: TE”</title>
    <rfc num="7230" sect="4.3">
      Since the <h>TE</h> header field only applies to the immediate connection, a
   sender of TE MUST also send a "TE" connection option within the
   <h>Connection</h> header field (Section 6.1) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.
    </rfc>
  </error>

  <comment id="1030">
    <title><ref to="header"/> was not announced in the <ref to="msg.headers.trailer"/> header</title>
    <rfc num="7230" sect="4.4">
      When a message includes a message body encoded with the <tc>chunked</tc>
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a <h>Trailer</h> header field before the message body to indicate
   which fields will be present in the trailers.
    </rfc>
  </comment>

  <error id="1031">
    <title>Request without a <h>Host</h> header</title>
    <rfc num="7230" sect="5.4">
      A client MUST send a <h>Host</h> header field in all <ref to="msg.version">HTTP/1.1</ref> request
   messages.
    </rfc>
  </error>

  <comment id="1032">
    <title><ref to="msg.headers.host"/> is not the first request header</title>
    <rfc num="7230" sect="5.4">
      Since the <h>Host</h> field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.
    </rfc>
  </comment>

  <error id="1033">
    <title><ref to="msg.status"/> response to a request with a bad <ref to="msg.request.headers.host"/> header</title>
    <rfc num="7230" sect="5.4">
      A server MUST respond with a <st>400</st> (Bad Request) status code to any
   <ref to="msg.request.version">HTTP/1.1</ref> request message that lacks a <h>Host</h> header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.
    </rfc>
  </error>

  <error id="1034">
    <title><ref to="header"/> listed in the <ref to="msg.headers.connection"/> header</title>
    <rfc num="7230" sect="5.4">
      A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, <h>Cache-Control</h> is never appropriate as a connection option
   (Section 5.2 of [RFC7234]).
    </rfc>
  </error>

  <comment id="1035">
    <title>Using deprecated media type <ref to="msg.headers.content_type.value"/></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload body is of type <ref to="msg.headers.content_type.value"/>, which is listed as “deprecated” or “obsoleted” in the <cite title="IANA media types registry" url="http://www.iana.org/assignments/media-types/media-types.xml"/>.</explain>
  </comment>

  <internal id="1036">
    <title>Not decoding <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> content coding. (This doesn’t mean that it’s wrong.)</explain>
  </internal>

  <error id="1037">
    <title>Could not decode <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1038">
    <title>Bad JSON <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is JSON, but HTTPolice tried to parse it as JSON and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1039">
    <title>Bad XML <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is XML, but HTTPolice tried to parse it as XML and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1040">
    <title>Bad URL-encoded <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is URL-encoded. But it doesn’t look like a proper URL-encoded string, as defined by <cite title="HTML5" url="http://www.w3.org/TR/html/forms.html#url-encoded-form-data"/>, because it contains a byte with the value <ref to="offending_value"/>.</explain>
    <explain>More often than not, this means that the <ref to="msg.headers.content_type"/> header is wrong.</explain>
  </error>

  <comment id="1041">
    <title>Message with a <ref to="msg.body">payload</ref> but no <h>Content-Type</h></title>
    <rfc num="7231" sect="3.1.1.5">
      A sender that generates a message containing a payload body SHOULD
   generate a <h>Content-Type</h> header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.
    </rfc>
  </comment>

  <error id="1042">
    <title>More than one ‘<ref to="param"/>’ parameter in <ref to="msg.headers.content_type"/></title>
    <rfc num="6838" sect="4.3">
      It is an error for a specific
   parameter to be specified more than once.
    </rfc>
  </error>

  <error id="1043">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <rfc num="7231" sect="4.3.6">
      A client sending a <m>CONNECT</m> request MUST send the authority form of
   request-target (Section 5.3 of [RFC7230]); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.
    </rfc>
    <explain>See also <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <error id="1044">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <explain>The target of an <m>OPTIONS</m> request must be in the origin form (the usual path + query), the asterisk form (*), or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/> and <rfc num="7231" sect="4.3.7"/>.</explain>
  </error>

  <error id="1045">
    <title><ref to="msg.method"/> request with <ref to="msg.target">target</ref> in a wrong form</title>
    <explain>The target of a <ref to="msg.method"/> request must be in either the origin form (the usual path + query) or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <warning id="1046">
    <title>No <h>Via</h> in a response to a proxied request</title>
    <explain>This is a response to a request sent through a proxy (judging by the form of the <ref to="msg.request.target">request target</ref>). <rfc num="7230" sect="5.7.1"/> requires that a proxy add a <h>Via</h> header to each message that it forwards. But the response has no such header.</explain>
    <explain>Therefore, unless the response was generated by the proxy itself, it’s either missing the Via header, or the request uses the wrong form of target (absolute form instead of origin form—see <rfc num="7230" sect="5.3"/>).</explain>
  </warning>

  <comment id="1047">
    <title>No “<ref to="msg.headers.connection"/>: close” in a close-delimited response</title>
    <explain>This response includes no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <explain>But the server neglected to send a ‘close’ option in the <h>Connection</h> header, as specified in <rfc num="7230" sect="6.3"/> and <rfc num="7230" sect="6.6"/>.</explain>
  </comment>

  <error id="1048">
    <title><ref to="msg.status"/> response without an <h>Upgrade</h> header</title>
    <rfc num="7230" sect="6.7">
      A server that sends a <st>101</st> (Switching Protocols) response MUST send an
   <h>Upgrade</h> header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.
    </rfc>
  </error>

  <error id="1049">
    <title><ref to="msg.status">Switching</ref> to a <ref to="msg.headers.upgrade">protocol</ref> that was not <ref to="msg.request.headers.upgrade">requested</ref></title>
    <rfc num="7230" sect="6.7">
      A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's <h>Upgrade</h> header field.
    </rfc>
  </error>

  <error id="1050">
    <title><ref to="msg.headers.upgrade"/> header without “<ref to="msg.headers.connection"/>: upgrade”</title>
    <rfc num="7230" sect="6.7">
      When <h>Upgrade</h> is sent, the sender MUST also send a <h>Connection</h> header
   field (Section 6.1) that contains an "upgrade" connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.
    </rfc>
  </error>

  <error id="1051">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.version"/> request</title>
    <rfc num="7230" sect="6.7">
      A
   server MUST ignore an <h>Upgrade</h> header field that is received in an
   HTTP/1.0 request.
    </rfc>
  </error>

  <error id="1052">
    <title><ref to="header"/> in a <ref to="msg.status"/> response</title>
    <explain>The <ref to="header"/> header provides representation metadata, but there can be no representation associated with a <ref to="msg.status"/> response. The header should probably be removed.</explain>
  </error>

  <error id="1053">
    <title><ref to="header"/> in a request with no payload</title>
    <explain>The <ref to="header"/> header provides representation metadata. It would make sense in a request with a payload, but this one has no payload.</explain>
    <explain>See also <rfc num="7231" sect="3.1"/>.</explain>
  </error>

  <error id="1054">
    <title><ref to="msg.headers.trailer"/> header in a message without a chunked body</title>
    <explain>The <ref to="msg.headers.trailer"/> header announces what other headers will be sent in the trailer part of a <tc>chunked</tc> message. It doesn’t make sense for this message because it <ref to="msg.headers.transfer_encoding">does not use</ref> the chunked transfer coding.</explain>
    <explain>See also <rfc num="7230" sect="4.1.2"/>.</explain>
    <!-- It would be more interesting to check that the header announced by ``Trailer`` is actually present there, but I don't think this is feasible, because many/most implementations (which are going to supply us with parsed messages) don't provide access to the trailer part at all. -->
  </error>

  <comment id="1055">
    <title>Unnecessary <ref to="msg.headers.content_location"/></title>
    <explain>This is a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request. By definition, its payload is a representation of the requested resource. But it also contains a <ref to="msg.headers.content_location"/> header that points to the same URI as the request URI. In this case, the header provides no additional information.</explain>
    <explain>See also <rfc num="7231" sect="3.1.4.1"/>.</explain>
  </comment>

  <warning id="1056">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.1">
      A payload within a <m>GET</m> request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.
    </rfc>
  </warning>

  <warning id="1057">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.2">
      A payload within a <m>HEAD</m> request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.
    </rfc>
  </warning>

  <error id="1058">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request with <ref to="msg.request.headers.content_range"/></title>
    <rfc num="7231" sect="4.3.4">
      An origin server that allows <m>PUT</m> on a given target resource MUST send
   a <st>400</st> (Bad Request) response to a PUT request that contains a
   <h>Content-Range</h> header field (Section 4.2 of [RFC7233]), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.
    </rfc>
  </error>

  <warning id="1059">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.5">
      A payload within a <m>DELETE</m> request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.
    </rfc>
  </warning>

  <warning id="1060">
    <title>Strange <ref to="msg.headers.content_location"/> in a response to a <ref to="msg.request.method"/> request</title>
    <explain>This is an ostensibly successful (<ref to="msg.status"/>) response to a <ref to="msg.request.method"/> request. However, according to its <ref to="msg.headers.content_location"/> header, it carries a representation of the target resource—the one that should have been deleted. This probably means that either the <ref to="msg.headers.content_location"/> is wrong, or the request did not actually succeed.</explain>
  </warning>

  <warning id="1061">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.6">
      A payload within a <m>CONNECT</m> request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.
    </rfc>
  </warning>

  <error id="1062">
    <title><ref to="msg.method"/> request with a payload but no <h>Content-Type</h></title>
    <rfc num="7231" sect="4.3.7">
      A client that generates an <m>OPTIONS</m> request containing a payload body
   MUST send a valid <h>Content-Type</h> header field describing the
   representation media type.
    </rfc>
  </error>

</notices>
