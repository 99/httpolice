<?xml version="1.0" encoding="utf-8"?>

<notices>

  <error id="1000">
    <title>Malformed <ref to="header"/> header</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1001">
    <title>Final <ref to="msg.headers.transfer_encoding"/> is not <tc>chunked</tc></title>
    <rfc num="7230" sect="3.3.1">
      If any transfer coding
   other than <tc>chunked</tc> is applied to a request payload body, the sender
   MUST apply <tc>chunked</tc> as the final transfer coding to ensure that the
   message is properly framed.
    </rfc>
  </error>

  <error id="1002">
    <title><ref to="msg.headers.transfer_encoding"/> contains <tc>chunked</tc> more than once</title>
    <rfc num="7230" sect="3.3.1">
      A sender MUST
   NOT apply <tc>chunked</tc> more than once to a message body (i.e., chunking an
   already chunked message is not allowed).
    </rfc>
  </error>

  <debug id="1003">
    <title>Not decoding <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> transfer coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1004">
    <title>Incomplete message according to <ref to="msg.headers.content_length"/></title>
    <explain>This message’s <ref to="msg.headers.content_length"/> header indicates that the body is <ref to="msg.headers.content_length.value"/> bytes long, but there are fewer bytes remaining on the stream.</explain>
  </error>

  <error id="1005">
    <title>Malformed <ref to="msg.headers.transfer_encoding"/>: <tc>chunked</tc></title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1006">
    <title>Malformed request heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <debug id="1007">
    <title>Stop parsing request stream due to errors</title>
    <explain>Due to previous errors, the request stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </debug>

  <error id="1008">
    <title>Not enough requests for this response</title>
    <explain>If HTTPolice is parsing things correctly, it seems that there is no request corresponding to this response. HTTPolice will check this response in isolation.</explain>
  </error>

  <error id="1009">
    <title>Malformed response heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <debug id="1010">
    <title>Stop parsing response stream due to errors</title>
    <explain>Due to previous errors, the response stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </debug>

  <debug id="1011">
    <title>Stop parsing response stream after switching protocols</title>
    <explain>The response status code <ref to="msg.status"/> indicates that the connection has switched to a different protocol. HTTPolice will not parse the remainder of the response stream.</explain>
  </debug>

  <debug id="1012">
    <title>Stop parsing response stream after switching to a tunnel</title>
    <explain>A <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request indicates that the connection has switched to being a tunnel. HTTPolice will not parse the remainder of the response stream.</explain>
  </debug>

  <error id="1013">
    <title><ref to="entries">Multiple</ref> <ref to="header"/> headers</title>
    <rfc num="7230" sect="3.2.2">
      A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
    </rfc>
  </error>

  <comment id="1014">
    <title>RWS is not a single space in <ref to="place"/></title>
    <explain>The specification for <ref to="place"/> includes the rule named RWS. It should be generated by senders as just a single space, but here it was <ref to="num"/> characters. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </comment>

  <error id="1015">
    <title>Bad whitespace (BWS) in <ref to="place"/></title>
    <explain>The specification for <ref to="place"/> includes the rule named BWS, which is whitespace allowed for historical reasons; current implementations must omit it. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </error>

  <error id="1016">
    <title>Obsolete line folding in header fields</title>
    <explain>This message uses line folding (the ‘obs-fold’ rule) to split one header field over several physical lines, but this is deprecated and prohibited in most contexts. See <rfc num="7230" sect="3.2.4"/>.</explain>
  </error>

  <comment id="1017">
    <title>Superfluous escaping in <ref to="place"/></title>
    <explain>This message uses the ‘quoted-pair’ rule to escape the character <ref to="char"/> in a context where this escaping is unnecessary and should not be used. See <rfc num="7230" sect="3.2.6"/>.</explain>
    <explain>If a literal backslash \ was intended here, it should itself be escaped as \\.</explain>
  </comment>

  <error id="1018">
    <title><ref to="msg.headers.transfer_encoding"/> header in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).
    </rfc>
  </error>

  <error id="1019">
    <title><ref to="msg.headers.transfer_encoding"/> header in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in
   any 2xx (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <error id="1020">
    <title>Message with both <ref to="msg.headers.transfer_encoding"/> and <ref to="msg.headers.content_length"/></title>
    <rfc num="7230" sect="3.3.2">
      A sender MUST NOT send a <h>Content-Length</h> header field in any message
   that contains a <h>Transfer-Encoding</h> header field.
    </rfc>
  </error>

  <comment id="1021">
    <title><ref to="msg.method"/> request with no <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD send a <h>Content-Length</h> in a request message when
   no <h>Transfer-Encoding</h> is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a <m>POST</m> request even when the value is 0
   (indicating an empty payload body).
    </rfc>
  </comment>

  <comment id="1022">
    <title><ref to="msg.method"/> request with <ref to="msg.headers.content_length"/> but no body</title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD NOT send a
   <h>Content-Length</h> header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.
    </rfc>
  </comment>

  <error id="1023">
    <title><ref to="msg.headers.content_length"/> header in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.2">
      A server MUST NOT send a <h>Content-Length</h> header field in any response
   with a status code of 1xx (Informational) or <st>204</st> (No Content).
    </rfc>
  </error>

  <error id="1024">
    <title><ref to="msg.headers.content_length"/> header in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.2">
      A
   server MUST NOT send a <h>Content-Length</h> header field in any 2xx
   (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <comment id="1025">
    <title>Response delimited only by closing the connection</title>
    <explain>This response includes no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <rfc num="7230" sect="3.3.3">
      Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
    </rfc>
  </comment>

  <error id="1026">
    <title><ref to="header"/> in a trailer</title>
    <rfc num="7230" sect="4.1.2">
      A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., <h>Transfer-Encoding</h> and <h>Content-Length</h>),
   routing (e.g., <h>Host</h>), request modifiers (e.g., controls and
   conditionals in Section 5 of [RFC7231]), authentication (e.g., see
   [RFC7235] and [RFC6265]), response control data (e.g., see Section
   7.1 of [RFC7231]), or determining how to process the payload (e.g.,
   <h>Content-Encoding</h>, <h>Content-Type</h>, <h>Content-Range</h>, and <h>Trailer</h>).
    </rfc>
  </error>

  <error id="1027">
    <title>Could not decode <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1028">
    <title><ref to="msg.headers.te"/>: <tc>chunked</tc></title>
    <rfc num="7230" sect="4.3">
      A client MUST NOT send
   the <tc>chunked</tc> transfer coding name in <h>TE</h>; chunked is always acceptable
   for HTTP/1.1 recipients.
    </rfc>
  </error>

  <error id="1029">
    <title><ref to="msg.headers.te"/> without “<ref to="msg.headers.connection"/>: TE”</title>
    <rfc num="7230" sect="4.3">
      Since the <h>TE</h> header field only applies to the immediate connection, a
   sender of TE MUST also send a "TE" connection option within the
   <h>Connection</h> header field (Section 6.1) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.
    </rfc>
  </error>

  <comment id="1030">
    <title><ref to="header"/> was not announced in the <ref to="msg.headers.trailer"/> header</title>
    <rfc num="7230" sect="4.4">
      When a message includes a message body encoded with the <tc>chunked</tc>
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a <h>Trailer</h> header field before the message body to indicate
   which fields will be present in the trailers.
    </rfc>
  </comment>

  <error id="1031">
    <title>Request without a <h>Host</h> header</title>
    <rfc num="7230" sect="5.4">
      A client MUST send a <h>Host</h> header field in all <ref to="msg.version">HTTP/1.1</ref> request
   messages.
    </rfc>
  </error>

  <comment id="1032">
    <title><ref to="msg.headers.host"/> is not the first request header</title>
    <rfc num="7230" sect="5.4">
      Since the <h>Host</h> field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.
    </rfc>
  </comment>

  <error id="1033">
    <title><ref to="msg.status"/> response to a request with a bad <ref to="msg.request.headers.host"/> header</title>
    <rfc num="7230" sect="5.4">
      A server MUST respond with a <st>400</st> (Bad Request) status code to any
   <ref to="msg.request.version">HTTP/1.1</ref> request message that lacks a <h>Host</h> header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.
    </rfc>
  </error>

  <error id="1034">
    <title><ref to="header"/> listed in the <ref to="msg.headers.connection"/> header</title>
    <rfc num="7230" sect="5.4">
      A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, <h>Cache-Control</h> is never appropriate as a connection option
   (Section 5.2 of [RFC7234]).
    </rfc>
  </error>

  <comment id="1035">
    <title>Using deprecated media type <ref to="msg.headers.content_type.value"/></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload body is of type <ref to="msg.headers.content_type.value"/>, which is listed as “deprecated” or “obsoleted” in the <cite title="IANA media types registry" url="http://www.iana.org/assignments/media-types/media-types.xml"/>.</explain>
  </comment>

  <debug id="1036">
    <title>Not decoding <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> content coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1037">
    <title>Could not decode <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1038">
    <title>Bad JSON <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is JSON, but HTTPolice tried to parse it as JSON and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1039">
    <title>Bad XML <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is XML, but HTTPolice tried to parse it as XML and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1040">
    <title>Bad URL-encoded <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is URL-encoded. But it doesn’t look like a proper URL-encoded string, as defined by <cite title="HTML5" url="http://www.w3.org/TR/html/forms.html#url-encoded-form-data"/>, because it contains a byte with the value <ref to="offending_value"/>.</explain>
    <explain>More often than not, this means that the <ref to="msg.headers.content_type"/> header is wrong.</explain>
  </error>

  <comment id="1041">
    <title>Message with a <ref to="msg.body">payload</ref> but no <h>Content-Type</h></title>
    <rfc num="7231" sect="3.1.1.5">
      A sender that generates a message containing a payload body SHOULD
   generate a <h>Content-Type</h> header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.
    </rfc>
  </comment>

  <error id="1042">
    <title>More than one ‘<ref to="param"/>’ parameter in <ref to="msg.headers.content_type"/></title>
    <rfc num="6838" sect="4.3">
      It is an error for a specific
   parameter to be specified more than once.
    </rfc>
  </error>

  <error id="1043">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <rfc num="7231" sect="4.3.6">
      A client sending a <m>CONNECT</m> request MUST send the authority form of
   request-target (Section 5.3 of [RFC7230]); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.
    </rfc>
    <explain>See also <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <error id="1044">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <explain>The target of an <m>OPTIONS</m> request must be in the origin form (the usual path + query), the asterisk form (*), or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/> and <rfc num="7231" sect="4.3.7"/>.</explain>
  </error>

  <error id="1045">
    <title><ref to="msg.method"/> request with <ref to="msg.target">target</ref> in a wrong form</title>
    <explain>The target of a <ref to="msg.method"/> request must be in either the origin form (the usual path + query) or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <comment id="1046">
    <title>No <h>Via</h> in a response to a proxied request</title>
    <explain>This is a response to a request sent through a proxy (judging by the form of the <ref to="msg.request.target">request target</ref>). <rfc num="7230" sect="5.7.1"/> requires that a proxy add a <h>Via</h> header to each message that it forwards. But the response has no such header.</explain>
    <explain>Therefore, unless the response was generated by the proxy itself, it’s either missing the Via header, or the request uses the wrong form of target (absolute form instead of origin form—see <rfc num="7230" sect="5.3"/>).</explain>
  </comment>

  <comment id="1047">
    <title>No “<ref to="msg.headers.connection"/>: close” in a close-delimited response</title>
    <explain>This response includes no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <explain>But the server neglected to send a ‘close’ option in the <h>Connection</h> header, as specified in <rfc num="7230" sect="6.3"/> and <rfc num="7230" sect="6.6"/>.</explain>
  </comment>

  <error id="1048">
    <title><ref to="msg.status"/> response without an <h>Upgrade</h> header</title>
    <rfc num="7230" sect="6.7">
      A server that sends a <st>101</st> (Switching Protocols) response MUST send an
   <h>Upgrade</h> header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.
    </rfc>
  </error>

  <error id="1049">
    <title><ref to="msg.status">Switching</ref> to a <ref to="msg.headers.upgrade">protocol</ref> that was not <ref to="msg.request.headers.upgrade">requested</ref></title>
    <rfc num="7230" sect="6.7">
      A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's <h>Upgrade</h> header field.
    </rfc>
  </error>

  <error id="1050">
    <title><ref to="msg.headers.upgrade"/> header without “<ref to="msg.headers.connection"/>: upgrade”</title>
    <rfc num="7230" sect="6.7">
      When <h>Upgrade</h> is sent, the sender MUST also send a <h>Connection</h> header
   field (Section 6.1) that contains an "upgrade" connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.
    </rfc>
  </error>

  <error id="1051">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.version"/> request</title>
    <rfc num="7230" sect="6.7">
      A
   server MUST ignore an <h>Upgrade</h> header field that is received in an
   HTTP/1.0 request.
    </rfc>
  </error>

  <error id="1052">
    <title><ref to="header"/> in a <ref to="msg.status"/> response</title>
    <explain>The <ref to="header"/> header provides representation metadata, but there can be no representation associated with a <ref to="msg.status"/> response. The header should probably be removed.</explain>
  </error>

  <error id="1053">
    <title><ref to="header"/> in a request with no payload</title>
    <explain>The <ref to="header"/> header provides representation metadata. It would make sense in a request with a payload, but this one has no payload.</explain>
    <explain>See also <rfc num="7231" sect="3.1"/>.</explain>
  </error>

  <error id="1054">
    <title><ref to="msg.headers.trailer"/> header in a message without a chunked body</title>
    <explain>The <ref to="msg.headers.trailer"/> header announces what other headers will be sent in the trailer part of a <tc>chunked</tc> message. It doesn’t make sense for this message because it <ref to="msg.headers.transfer_encoding">does not use</ref> the chunked transfer coding.</explain>
    <explain>See also <rfc num="7230" sect="4.1.2"/>.</explain>
    <!-- It would be more interesting to check that the header announced by ``Trailer`` is actually present there, but I don't think this is feasible, because many/most implementations (which are going to supply us with parsed messages) don't provide access to the trailer part at all. -->
  </error>

  <comment id="1055">
    <title>Unnecessary <ref to="msg.headers.content_location"/></title>
    <explain>This is a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request. By definition, its payload is a representation of the requested resource. But it also contains a <ref to="msg.headers.content_location"/> header that points to the same URI as the request URI. In this case, the header provides no additional information.</explain>
    <explain>See also <rfc num="7231" sect="3.1.4.1"/>.</explain>
  </comment>

  <comment id="1056">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.1">
      A payload within a <m>GET</m> request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <comment id="1057">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.2">
      A payload within a <m>HEAD</m> request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1058">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request with <ref to="msg.request.headers.content_range"/></title>
    <rfc num="7231" sect="4.3.4">
      An origin server that allows <m>PUT</m> on a given target resource MUST send
   a <st>400</st> (Bad Request) response to a PUT request that contains a
   <h>Content-Range</h> header field (Section 4.2 of [RFC7233]), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.
    </rfc>
  </error>

  <comment id="1059">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.5">
      A payload within a <m>DELETE</m> request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1060">
    <title>Strange <ref to="msg.headers.content_location"/> in a response to a <ref to="msg.request.method"/> request</title>
    <explain>This is an ostensibly successful (<ref to="msg.status"/>) response to a <ref to="msg.request.method"/> request. However, according to its <ref to="msg.headers.content_location"/> header, it carries a representation of the target resource—the one that should have been deleted. This probably means that either the <ref to="msg.headers.content_location"/> is wrong, or the request did not actually succeed.</explain>
  </error>

  <comment id="1061">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.6">
      A payload within a <m>CONNECT</m> request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1062">
    <title><ref to="msg.method"/> request with a payload but no <h>Content-Type</h></title>
    <rfc num="7231" sect="4.3.7">
      A client that generates an <m>OPTIONS</m> request containing a payload body
   MUST send a valid <h>Content-Type</h> header field describing the
   representation media type.
    </rfc>
  </error>

  <error id="1063">
    <title><ref to="header"/> is a response header</title>
    <explain>This request includes the <ref to="header"/> header, which is defined for responses, but not for requests.</explain>
  </error>

  <error id="1064">
    <title><ref to="header"/> is a request header</title>
    <explain>This response includes the <ref to="header"/> header, which is defined for requests, but not for responses.</explain>
  </error>

  <error id="1065">
    <title><ref to="msg.headers.expect"/> is not ‘100-continue’</title>
    <explain>The <ref to="msg.headers.expect"/> header can only contain the value ‘100-continue’. It does not support any other expectations.</explain>
    <rfc num="7231" sect="5.1.1">
      The <h>Expect</h> header field was added after the original
      publication of HTTP/1.1 [RFC2068] as both the means to request an
      interim <st>100</st> (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.
    </rfc>
  </error>

  <error id="1066">
    <title>“<ref to="msg.headers.expect"/>: 100-continue” in a request with no payload</title>
    <rfc num="7231" sect="5.1.1">
      A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.
    </rfc>
  </error>

  <comment id="1067">
    <title><ref to="msg.headers.max_forwards"/> header in a <ref to="msg.method"/> request</title>
    <explain>The <ref to="msg.headers.max_forwards"/> header is only defined for <m>OPTIONS</m> and <m>TRACE</m> requests. <rfc num="7231" sect="5.1.2">A recipient MAY ignore a Max-Forwards header field received with any other request methods.</rfc></explain>
  </comment>

  <error id="1068">
    <title><ref to="msg.headers.referer"/> with an ‘https:’ scheme sent in an unsecured request</title>
    <rfc num="7231" sect="5.5.2">
      A user agent MUST NOT send a <h>Referer</h> header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.
    </rfc>
  </error>

  <comment id="1070">
    <title>Request without a <h>User-Agent</h> header</title>
    <rfc num="7231" sect="5.5.3">
      A user agent SHOULD send a <h>User-Agent</h> field in each request
   unless specifically configured not to do so.
    </rfc>
  </comment>

  <error id="1071">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.version"/> request</title>
    <rfc num="7231" sect="6.2">
      Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.
    </rfc>
  </error>

  <error id="1072">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.request.method"/> method is defined to be safe (read-only). But the <st>201</st> status code indicates that a new resource was created. Either one is wrong here.</explain>
  </error>

  <comment id="1073">
    <title>Possibly missing <h>Location</h> header</title>
    <explain>This <ref to="msg.status"/> response indicates that a new resource was created. Because there is no <h>Location</h> header in the response, it is assumed that the created resource is the same as the request target (<rfc num="7231" sect="6.3.2"/>). But <ref to="msg.request.method"/> requests are usually intended to create a sub-resource of the target resource. Therefore, it’s likely that this response needs an explicit <h>Location</h>.</explain>
  </comment>

  <error id="1074">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.request.method"/> method is defined to be safe (read-only). But the <st>202</st> status code means that the server started some kind of processing operation. Either one is wrong here.</explain>
  </error>

  <error id="1075">
    <title><ref to="msg.status"/> response with no <h>Via</h> header</title>
    <explain>The <ref to="msg.status"/> status code means that the response has been transformed by a proxy. But a proxy must also add a <h>Via</h> header to each forwarded response (<rfc num="7230" sect="5.7.1"/>), and there is no such header here.</explain>
  </error>

  <error id="1076">
    <title><ref to="msg.status"/> response with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="6.3.6">
      Since the <st>205</st> status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.
    </rfc>
  </error>

  <comment id="1077">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.4.1">
      For request methods other than <m>HEAD</m>, the server SHOULD generate a
   payload in the <st>300</st> response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.
    </rfc>
  </comment>

  <comment id="1078">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.2">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a preferred URI reference for the new permanent URI.
    </rfc>
  </comment>

  <comment id="1079">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.3">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1080">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.4">
      The <st>303</st> (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the <h>Location</h> header field, which is intended to provide an
   indirect response to the original request.
    </rfc>
  </error>

  <comment id="1081">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.4.4">
      Except for responses to a <m>HEAD</m> request, the representation of a <st>303</st>
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the <h>Location</h> header field.
    </rfc>
  </comment>

  <error id="1082">
    <title>Using deprecated status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.4.5">
      The <st>305</st> (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).
    </rfc>
  </error>

  <error id="1083">
    <title>Using reserved status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.4.6">
      The <st>306</st> status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.
    </rfc>
  </error>

  <comment id="1084">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.7">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1085">
    <title>Redirection to the same URI</title>
    <explain>This <ref to="msg.status"/> response includes a <ref to="msg.headers.location"/> header that points to the same URI as the <ref to="msg.request.target">request URI</ref>. So the resource redirects to itself.</explain>
  </error>

  <error id="1086">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.target">server-wide</ref> <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.status"/> status code means that the target resource can be found at a different URI. But this was an “<m>OPTIONS</m> *” request—it targets the entire server, not any particular resource. So the <ref to="msg.status"/> status code makes no sense here.</explain>
    <explain>Perhaps the <st>303</st> status code would fit better.</explain>
  </error>

  <comment id="1087">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1088">
    <title>Using reserved status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.5.2">
      The <st>402</st> (Payment Required) status code is reserved for future use.
    </rfc>
  </error>

  <error id="1089">
    <title><ref to="msg.status"/> response with no <h>Allow</h> header</title>
    <rfc num="7231" sect="6.5.5">
      The origin server MUST generate an
   <h>Allow</h> header field in a <st>405</st> response containing a list of the target
   resource's currently supported methods.
    </rfc>
  </error>

  <error id="1090">
    <title>Wrong use of status code <ref to="msg.status"/></title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers, such as <h>Accept</h>. But this request has no such headers.</explain>
    <explain>See also <rfc num="7231" sect="5.3"/>.</explain>
  </error>

  <comment id="1091">
    <title>Probably wrong use of status code <ref to="msg.status"/></title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers, such as <h>Accept</h>. But this request has no such headers, unless it’s an extension header not known to HTTPolice.</explain>
    <explain>See also <rfc num="7231" sect="5.3"/>.</explain>
  </comment>

  <comment id="1092">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5.6">
      The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.
    </rfc>
  </comment>

  <comment id="1093">
    <title><ref to="msg.headers.user_agent"/> contains no actual product</title>
    <explain>This request’s <h>User-Agent</h> header contains only the name of the underlying library, which isn’t very useful for identifying the request. It might be a good idea to include the name of the actual product.</explain>
    <explain>For example: “My-Product/1.0 <ref to="library"/>”.</explain>
    <explain>Or simply “My-Product/1.0” or “My-Product”.</explain>
    <explain>See <rfc num="7231" sect="5.5.3"/>.</explain>
  </comment>

  <comment id="1094">
    <title><ref to="msg.status"/> response without “<ref to="msg.headers.connection"/>: close”</title>
    <rfc num="7231" sect="6.5.7">
      A server SHOULD send the "close" connection option
   (Section 6.1 of [RFC7230]) in the response, since <st>408</st> implies that
   the server has decided to close the connection rather than continue
   waiting.
    </rfc>
  </comment>

  <error id="1095">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <explain>The <st>409</st> status code means that the request conflicted with the current state of the resource. But a <ref to="msg.request.method"/> request is, by definition, safe (read-only): it must not affect the state in any way, so there can be no conflict. The 409 status code is probably wrong here.</explain>
  </error>

  <comment id="1096">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5.8">
      The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.
    </rfc>
  </comment>

  <error id="1097">
    <title><ref to="msg.status"/> response to a request with <ref to="msg.request.headers.content_length"/></title>
    <explain>The <st>411</st> status code means that the server wants to see a <h>Content-Length</h> header in the request. But this request did, in fact, include a valid Content-Length of <ref to="msg.request.headers.content_length.value"/>.</explain>
  </error>

  <error id="1098">
    <title><ref to="msg.status"/> response to a request with no payload</title>
    <rfc num="7231" sect="6.5.11">
      The <st>413</st> (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.
    </rfc>
  </error>

  <error id="1099">
    <title><ref to="msg.status"/> response to a request with no payload</title>
    <rfc num="7231" sect="6.5.13">
      The <st>415</st> (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
    </rfc>
  </error>

  <error id="1100">
    <title><ref to="msg.status"/> response to a request with no <h>Expect</h></title>
    <rfc num="7231" sect="6.5.14">
      The <st>417</st> (Expectation Failed) status code indicates that the
   expectation given in the request's <h>Expect</h> header field
   (Section 5.1.1) could not be met by at least one of the inbound
   servers.
    </rfc>
  </error>

  <error id="1101">
    <title><ref to="msg.status"/> response with no <h>Upgrade</h> header</title>
    <rfc num="7231" sect="6.5.15">
      The server MUST send an Upgrade header field in a <st>426</st>
   response to indicate the required protocol(s) (Section 6.7 of
   [RFC7230]).
    </rfc>
  </error>

  <error id="1102">
    <title>Unnecessary <ref to="msg.status"/> response</title>
    <explain>In this response, the server <ref to="msg.headers.upgrade">demands</ref> that the client upgrade to <ref to="protocol"/>. But the client’s request is already offering that same upgrade in its own <ref to="msg.request.headers.upgrade"/> header. The server can just send a <st>101</st> response and switch to <ref to="protocol"/> without sending an error.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
  </error>

  <error id="1103">
    <title>Not proceeding with protocol upgrade</title>
    <explain>This response’s <ref to="msg.headers.upgrade"/> header indicates that the server is ready to upgrade to <ref to="protocol"/>. But the client’s request is already offering that same upgrade in its own <ref to="msg.request.headers.upgrade"/> header. If the server actually wants to switch to <ref to="protocol"/>, it should go ahead, send a <st>101</st> response, and switch.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
  </error>

  <comment id="1104">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.6">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1105">
    <title><ref to="msg.status"/> response with the same version as the request</title>
    <explain>The <st>505</st> status code means that the server does not support the HTTP version used in the request—which is <ref to="msg.request.version"/>—but the response itself <ref to="msg.version">is</ref> of that same version.</explain>
    <rfc num="7230" sect="2.6">
      A server MUST NOT send
   a version to which it is not conformant.
    </rfc>
  </error>

  <comment id="1106">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.6.6">
      The server SHOULD
   generate a representation for the <st>505</st> response that describes why
   that version is not supported and what other protocols are supported
   by that server.
    </rfc>
  </comment>

  <error id="1107">
    <title>Obsolete date format in <ref to="place"/></title>
    <rfc num="7231" sect="7.1.1.1">
      When a sender generates a
   header field that contains one or more timestamps defined as
   HTTP-date, the sender MUST generate those timestamps in the
   IMF-fixdate format.
    </rfc>
  </error>

  <error id="1108">
    <title>Wrong day of week in <ref to="place"/></title>
    <explain>This message’s <ref to="place"/> claims that <ref to="date"/> is <ref to="claimed"/>, but in reality it’s <ref to="actual"/>.</explain>
  </error>

  <error id="1109">
    <title><ref to="msg.headers.date"/> header is in the future</title>
    <explain>The <h>Date</h> header contains the date and time at which the message was originated, but in this message it appears to be in the future.</explain>
    <explain>This might be due to wrong timezone settings.</explain>
  </error>

  <comment id="1110">
    <title><ref to="msg.status"/> response with no <h>Date</h> header</title>
    <explain>According to <rfc num="7231" sect="7.1.1.2"/>, any <ref to="msg.status"/> response must include a <h>Date</h> header, unless the server has no usable clock.</explain>
  </comment>

  <error id="1111">
    <title><ref to="msg.headers.location"/> with a fragment (#) in a <ref to="msg.status"/> response</title>
    <rfc num="7231" sect="7.1.2">
      There are circumstances in which a fragment identifier in a <h>Location</h>
   value would not be appropriate.  For example, the Location header
   field in a <st>201</st> (Created) response is supposed to provide a URI that
   is specific to the created resource.
    </rfc>
  </error>

  <comment id="1112">
    <title><ref to="msg.headers.location"/> header in a <ref to="msg.status"/> response</title>
    <explain><rfc num="7231" sect="7.1.2"/> does not define what it means for a <ref to="msg.status"/> response to have a <ref to="msg.headers.location"/> header. Of course, other documents (unknown to HTTPolice) may do so.</explain>
  </comment>

  <comment id="1113">
    <title><ref to="msg.headers.retry_after"/> header in a <ref to="msg.status"/> response</title>
    <explain><rfc num="7231"/> defines the meaning of the <h>Retry-After</h> header for status codes 3xx, <st>413</st> and <st>503</st>, but not for <ref to="msg.status"/>. Other documents (unknown to HTTPolice) may add such meaning, though.</explain>
  </comment>

  <error id="1114">
    <title><ref to="msg.headers.allow"/> actually includes <ref to="msg.request.method"/></title>
    <explain>The <ref to="msg.status"/> status code means that the request method, which is <ref to="msg.request.method"/>, is not allowed for this resource. But the response’s <h>Allow</h> header does include <ref to="msg.request.method"/>. Either the status code or the <h>Allow</h> header is wrong here.</explain>
  </error>

  <error id="1115">
    <title><ref to="msg.headers.allow"/> does not include <ref to="msg.request.method"/></title>
    <explain>The <ref to="msg.status"/> status code means that this <ref to="msg.request.method"/> request was handled successfully. But, according to the <h>Allow</h> header, it should have been disallowed (status code <st>405</st>). Either the status code or the <h>Allow</h> header is wrong here.</explain>
  </error>

</notices>
