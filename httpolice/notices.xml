<?xml version="1.0" encoding="utf-8"?>

<notices>

  <error id="1000">
    <title>Malformed <ref to="entry"/> header</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1001">
    <title>Final <ref to="msg.headers.transfer_encoding"/> is not <tc>chunked</tc></title>
    <rfc num="7230" sect="3.3.1">
      If any transfer coding
   other than <tc>chunked</tc> is applied to a request payload body, the sender
   MUST apply <tc>chunked</tc> as the final transfer coding to ensure that the
   message is properly framed.
    </rfc>
  </error>

  <error id="1002">
    <title><ref to="msg.headers.transfer_encoding"/> contains <tc>chunked</tc> more than once</title>
    <rfc num="7230" sect="3.3.1">
      A sender MUST
   NOT apply <tc>chunked</tc> more than once to a message body (i.e., chunking an
   already chunked message is not allowed).
    </rfc>
  </error>

  <debug id="1003">
    <title>Not decoding <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> transfer coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1004">
    <title>Incomplete message according to <ref to="msg.headers.content_length"/></title>
    <explain>This message’s <ref to="msg.headers.content_length"/> header indicates that the body is <ref to="msg.headers.content_length.value"/> bytes long, but there are fewer bytes remaining on the stream.</explain>
  </error>

  <error id="1005">
    <title>Malformed <ref to="msg.headers.transfer_encoding"/>: <tc>chunked</tc></title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <error id="1006">
    <title>Malformed request heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <debug id="1007">
    <title>Stop parsing request stream</title>
    <explain>Due to previous notices, the request stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </debug>

  <debug id="1008">
    <title>Not enough requests</title>
    <explain>There are unparsed bytes remaining on the response stream, but no requests that would correspond to them. HTTPolice will not try to parse the remaining bytes.</explain>
  </debug>

  <error id="1009">
    <title>Malformed response heading</title>
    <explain>Parse error: <ref to="error"/></explain>
  </error>

  <debug id="1010">
    <title>Stop parsing response stream</title>
    <explain>Due to previous notices, the response stream is in an undefined state at this point, and HTTPolice will not try to parse the remaining bytes.</explain>
  </debug>

  <debug id="1011">
    <title>Switching protocols</title>
    <explain>The <ref to="msg.status"/> status code means that the connection is switching to a different protocol. HTTPolice will not parse the remainder of the response stream.</explain>
  </debug>

  <debug id="1012">
    <title>Switching to a tunnel</title>
    <explain>A <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request means that the connection is becoming a tunnel. HTTPolice will not parse the remainder of the response stream.</explain>
  </debug>

  <error id="1013">
    <title><ref to="entries">Multiple</ref> <ref to="header"/> headers</title>
    <rfc num="7230" sect="3.2.2">
      A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
    </rfc>
  </error>

  <comment id="1014">
    <title>RWS is not a single space in <ref to="place"/></title>
    <explain>The syntax of <ref to="place"/> includes the rule named RWS. It should be generated as just a single space, but here it was <ref to="num"/> characters. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </comment>

  <error id="1015">
    <title>Bad whitespace (BWS) in <ref to="place"/></title>
    <explain>The syntax of <ref to="place"/> includes the rule named BWS, which is whitespace allowed for historical reasons; current implementations must omit it. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </error>

  <error id="1016">
    <title>Obsolete line folding in header fields</title>
    <explain>This message uses line folding (the ‘obs-fold’ rule) to split one header field over several physical lines, but this is deprecated and prohibited in most contexts. See <rfc num="7230" sect="3.2.4"/>.</explain>
  </error>

  <comment id="1017">
    <title>Superfluous escaping in <ref to="place"/></title>
    <explain>This message uses the ‘quoted-pair’ rule to escape the character <ref to="char"/> in a context where this escaping is unnecessary and should not be used. See <rfc num="7230" sect="3.2.6"/>.</explain>
    <explain>If a literal backslash \ was intended here, it should itself be escaped as \\.</explain>
  </comment>

  <error id="1018">
    <title><ref to="msg.headers.transfer_encoding"/> in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).
    </rfc>
  </error>

  <error id="1019">
    <title><ref to="msg.headers.transfer_encoding"/> in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a <h>Transfer-Encoding</h> header field in
   any 2xx (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <error id="1020">
    <title>Message with both <ref to="msg.headers.transfer_encoding"/> and <ref to="msg.headers.content_length"/></title>
    <rfc num="7230" sect="3.3.2">
      A sender MUST NOT send a <h>Content-Length</h> header field in any message
   that contains a <h>Transfer-Encoding</h> header field.
    </rfc>
  </error>

  <comment id="1021">
    <title><ref to="msg.method"/> request with no <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD send a <h>Content-Length</h> in a request message when
   no <h>Transfer-Encoding</h> is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a <m>POST</m> request even when the value is 0
   (indicating an empty payload body).
    </rfc>
  </comment>

  <comment id="1022">
    <title><ref to="msg.method"/> request with <ref to="msg.headers.content_length"/> but no body</title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD NOT send a
   <h>Content-Length</h> header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.
    </rfc>
  </comment>

  <error id="1023">
    <title><ref to="msg.headers.content_length"/> in a <ref to="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.2">
      A server MUST NOT send a <h>Content-Length</h> header field in any response
   with a status code of 1xx (Informational) or <st>204</st> (No Content).
    </rfc>
  </error>

  <error id="1024">
    <title><ref to="msg.headers.content_length"/> in a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7230" sect="3.3.2">
      A
   server MUST NOT send a <h>Content-Length</h> header field in any 2xx
   (Successful) response to a <m>CONNECT</m> request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <comment id="1025">
    <title>Response delimited only by closing the connection</title>
    <explain>This response has no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <rfc num="7230" sect="3.3.3">
      Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server SHOULD generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
    </rfc>
  </comment>

  <error id="1026">
    <title><ref to="entry"/> in a trailer</title>
    <rfc num="7230" sect="4.1.2">
      A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., <h>Transfer-Encoding</h> and <h>Content-Length</h>),
   routing (e.g., <h>Host</h>), request modifiers (e.g., controls and
   conditionals in Section 5 of [RFC7231]), authentication (e.g., see
   [RFC7235] and [RFC6265]), response control data (e.g., see Section
   7.1 of [RFC7231]), or determining how to process the payload (e.g.,
   <h>Content-Encoding</h>, <h>Content-Type</h>, <h>Content-Range</h>, and <h>Trailer</h>).
    </rfc>
  </error>

  <error id="1027">
    <title>Could not decode <ref to="msg.headers.transfer_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1028">
    <title><ref to="msg.headers.te"/>: <tc>chunked</tc></title>
    <rfc num="7230" sect="4.3">
      A client MUST NOT send
   the <tc>chunked</tc> transfer coding name in <h>TE</h>; chunked is always acceptable
   for HTTP/1.1 recipients.
    </rfc>
  </error>

  <error id="1029">
    <title><ref to="msg.headers.te"/> without “<ref to="msg.headers.connection"/>: TE”</title>
    <rfc num="7230" sect="4.3">
      Since the <h>TE</h> header field only applies to the immediate connection, a
   sender of TE MUST also send a "TE" connection option within the
   <h>Connection</h> header field (Section 6.1) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.
    </rfc>
  </error>

  <comment id="1030">
    <title><ref to="header"/> was not announced in the <ref to="msg.headers.trailer"/> header</title>
    <rfc num="7230" sect="4.4">
      When a message includes a message body encoded with the <tc>chunked</tc>
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a <h>Trailer</h> header field before the message body to indicate
   which fields will be present in the trailers.
    </rfc>
  </comment>

  <error id="1031">
    <title>Request without a <h>Host</h> header</title>
    <rfc num="7230" sect="5.4">
      A client MUST send a <h>Host</h> header field in all <ref to="msg.version">HTTP/1.1</ref> request
   messages.
    </rfc>
  </error>

  <comment id="1032">
    <title><ref to="msg.headers.host"/> is not the first request header</title>
    <rfc num="7230" sect="5.4">
      Since the <h>Host</h> field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.
    </rfc>
  </comment>

  <error id="1033">
    <title><ref to="msg.status"/> response to a request with a bad <ref to="msg.request.headers.host"/> header</title>
    <rfc num="7230" sect="5.4">
      A server MUST respond with a <st>400</st> (Bad Request) status code to any
   <ref to="msg.request.version">HTTP/1.1</ref> request message that lacks a <h>Host</h> header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.
    </rfc>
  </error>

  <error id="1034">
    <title><ref to="header"/> listed in the <ref to="msg.headers.connection"/> header</title>
    <rfc num="7230" sect="5.4">
      A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, <h>Cache-Control</h> is never appropriate as a connection option
   (Section 5.2 of [RFC7234]).
    </rfc>
  </error>

  <comment id="1035">
    <title>Using deprecated media type <ref to="msg.headers.content_type.value"/></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is of type <ref to="msg.headers.content_type.value"/>, which is listed as “deprecated” or “obsoleted” in the <cite title="IANA media types registry" url="http://www.iana.org/assignments/media-types/media-types.xml"/>.</explain>
  </comment>

  <debug id="1036">
    <title>Not decoding <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>HTTPolice does not know how to decode the <ref to="coding"/> content coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1037">
    <title>Could not decode <ref to="msg.headers.content_encoding"/>: <ref to="coding"/></title>
    <explain>Error: <ref to="error"/></explain>
  </error>

  <error id="1038">
    <title>Bad JSON <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is JSON, but HTTPolice tried to parse it as JSON and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1039">
    <title>Bad XML <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is XML, but HTTPolice tried to parse it as XML and got the following error: <ref to="error"/></explain>
  </error>

  <error id="1040">
    <title>Bad URL-encoded <ref to="msg.body">payload</ref></title>
    <explain>According to <ref to="msg.headers.content_type"/>, this message’s payload is URL-encoded. But it doesn’t look like a proper URL-encoded string, as defined by <cite title="HTML5" url="http://www.w3.org/TR/html/forms.html#url-encoded-form-data"/>, because it contains a byte with the value <ref to="offending_value"/>.</explain>
    <explain>This often means that the <ref to="msg.headers.content_type"/> header is wrong.</explain>
  </error>

  <comment id="1041">
    <title><ref to="msg.body">Payload</ref> with no <h>Content-Type</h></title>
    <rfc num="7231" sect="3.1.1.5">
      A sender that generates a message containing a payload body SHOULD
   generate a <h>Content-Type</h> header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.
    </rfc>
  </comment>

  <comment id="1042">
    <title>More than one ‘<ref to="param"/>’ parameter in <ref to="msg.headers.content_type"/></title>
    <rfc num="6838" sect="4.3">
      It is an error for a specific
   parameter to be specified more than once.
    </rfc>
    <!-- This is a comment, not an error, because I'm not even sure this is correct: RFC 6838 is merely a BCP, and the requirement is not stated in RFC 2045/2046, and it's not even clear to me that RFC 6838 refers to the actual usage of parameters rather than their definition. -->
  </comment>

  <error id="1043">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <rfc num="7231" sect="4.3.6">
      A client sending a <m>CONNECT</m> request MUST send the authority form of
   request-target (Section 5.3 of [RFC7230]); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.
    </rfc>
    <explain>See also <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <error id="1044">
    <title><ref to="msg.method"/> request with a wrong <ref to="msg.target">target</ref></title>
    <explain>The target of an <m>OPTIONS</m> request must be in the origin form (the usual path + query), the asterisk form (*), or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/> and <rfc num="7231" sect="4.3.7"/>.</explain>
  </error>

  <error id="1045">
    <title><ref to="msg.method"/> request with <ref to="msg.target">target</ref> in a wrong form</title>
    <explain>The target of a <ref to="msg.method"/> request must be in either the origin form (the usual path + query) or the absolute form (beginning with http://, only when behind a proxy). See <rfc num="7230" sect="5.3"/>.</explain>
  </error>

  <comment id="1046">
    <title>No <h>Via</h> header in a proxied response</title>
    <explain>This is a response to a request sent through a proxy (judging by the form of the <ref to="msg.request.target">request target</ref>). <rfc num="7230" sect="5.7.1"/> requires that a proxy add a <h>Via</h> header to each message that it forwards. But the response has no such header.</explain>
    <explain>Therefore, unless the response was generated by the proxy itself, it’s either missing the Via header, or the request uses the wrong form of target (absolute form instead of origin form—see <rfc num="7230" sect="5.3"/>).</explain>
  </comment>

  <comment id="1047">
    <title>No “<ref to="msg.headers.connection"/>: close” in a close-delimited response</title>
    <explain>This response has no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection.</explain>
    <explain>But the server neglected to send a ‘close’ option in the <h>Connection</h> header, as specified in <rfc num="7230" sect="6.3"/> and <rfc num="7230" sect="6.6"/>.</explain>
  </comment>

  <error id="1048">
    <title><ref to="msg.status"/> response with no <h>Upgrade</h> header</title>
    <rfc num="7230" sect="6.7">
      A server that sends a <st>101</st> (Switching Protocols) response MUST send an
   <h>Upgrade</h> header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.
    </rfc>
  </error>

  <error id="1049">
    <title><ref to="msg.status">Switching</ref> to a <ref to="msg.headers.upgrade">protocol</ref> that was not <ref to="msg.request.headers.upgrade">requested</ref></title>
    <rfc num="7230" sect="6.7">
      A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's <h>Upgrade</h> header field.
    </rfc>
  </error>

  <error id="1050">
    <title><ref to="msg.headers.upgrade"/> header without “<ref to="msg.headers.connection"/>: upgrade”</title>
    <rfc num="7230" sect="6.7">
      When <h>Upgrade</h> is sent, the sender MUST also send a <h>Connection</h> header
   field (Section 6.1) that contains an "upgrade" connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.
    </rfc>
  </error>

  <error id="1051">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.version"/> request</title>
    <rfc num="7230" sect="6.7">
      A
   server MUST ignore an <h>Upgrade</h> header field that is received in an
   HTTP/1.0 request.
    </rfc>
  </error>

  <error id="1052">
    <title><ref to="header"/> in a <ref to="msg.status"/> response</title>
    <explain>The <ref to="header"/> header provides representation metadata, but there can be no representation associated with a <ref to="msg.status"/> response. The header should probably be removed.</explain>
  </error>

  <error id="1053">
    <title><ref to="header"/> in a request with no payload</title>
    <explain>The <ref to="header"/> header provides representation metadata. It would make sense in a request with a payload, but this one has no payload.</explain>
    <explain>See also <rfc num="7231" sect="3.1"/>.</explain>
  </error>

  <error id="1054">
    <title><ref to="msg.headers.trailer"/> header in a message with no chunked body</title>
    <explain>The <ref to="msg.headers.trailer"/> header announces what other headers will be sent in the trailer part of a <tc>chunked</tc> message. It doesn’t make sense for this message because it <ref to="msg.headers.transfer_encoding">does not use</ref> the chunked transfer coding.</explain>
    <explain>See also <rfc num="7230" sect="4.1.2"/>.</explain>
    <!-- It would be more interesting to check that the header announced by ``Trailer`` is actually present there, but I don't think this is feasible, because many/most implementations (which are going to supply us with parsed messages) don't provide access to the trailer part at all. -->
  </error>

  <comment id="1055">
    <title>Unnecessary <ref to="msg.headers.content_location"/></title>
    <explain>This is a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request. By definition, its payload is a representation of the requested resource. But it also contains a <ref to="msg.headers.content_location"/> header that points to the same URI as the request URI. In this case, the header provides no additional information.</explain>
    <explain>See also <rfc num="7231" sect="3.1.4.1"/>.</explain>
  </comment>

  <comment id="1056">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.1">
      A payload within a <m>GET</m> request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <comment id="1057">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.2">
      A payload within a <m>HEAD</m> request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1058">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request with <ref to="msg.request.headers.content_range"/></title>
    <rfc num="7231" sect="4.3.4">
      An origin server that allows <m>PUT</m> on a given target resource MUST send
   a <st>400</st> (Bad Request) response to a PUT request that contains a
   <h>Content-Range</h> header field (Section 4.2 of [RFC7233]), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.
    </rfc>
  </error>

  <comment id="1059">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.5">
      A payload within a <m>DELETE</m> request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1060">
    <title>Strange <ref to="msg.headers.content_location"/> in a response to a <ref to="msg.request.method"/> request</title>
    <explain>This is an ostensibly successful (<ref to="msg.status"/>) response to a <ref to="msg.request.method"/> request. However, according to its <ref to="msg.headers.content_location"/> header, it carries a representation of the target resource—the one that should have been deleted. This probably means that either the Content-Location is wrong, or the request did not actually succeed.</explain>
  </error>

  <comment id="1061">
    <title><ref to="msg.method"/> request with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="4.3.6">
      A payload within a <m>CONNECT</m> request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1062">
    <title><ref to="msg.method"/> request with a payload but no <h>Content-Type</h></title>
    <rfc num="7231" sect="4.3.7">
      A client that generates an <m>OPTIONS</m> request containing a payload body
   MUST send a valid <h>Content-Type</h> header field describing the
   representation media type.
    </rfc>
  </error>

  <error id="1063">
    <title><ref to="header"/> is a response header</title>
    <explain>This request includes the <ref to="header"/> header, which is defined for responses, but not for requests.</explain>
  </error>

  <error id="1064">
    <title><ref to="header"/> is a request header</title>
    <explain>This response includes the <ref to="header"/> header, which is defined for requests, but not for responses.</explain>
  </error>

  <error id="1065">
    <title><ref to="msg.headers.expect"/> is not ‘100-continue’</title>
    <explain>The <ref to="msg.headers.expect"/> header can only contain the value ‘100-continue’. It does not support any other expectations.</explain>
    <rfc num="7231" sect="5.1.1">
      The <h>Expect</h> header field was added after the original
      publication of HTTP/1.1 [RFC2068] as both the means to request an
      interim <st>100</st> (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.
    </rfc>
  </error>

  <error id="1066">
    <title>“<ref to="msg.headers.expect"/>: 100-continue” in a request with no payload</title>
    <rfc num="7231" sect="5.1.1">
      A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.
    </rfc>
  </error>

  <comment id="1067">
    <title><ref to="msg.headers.max_forwards"/> header in a <ref to="msg.method"/> request</title>
    <explain>The <ref to="msg.headers.max_forwards"/> header is only defined for <m>OPTIONS</m> and <m>TRACE</m> requests. <rfc num="7231" sect="5.1.2">A recipient MAY ignore a Max-Forwards header field received with any other request methods.</rfc></explain>
  </comment>

  <error id="1068">
    <title><ref to="msg.headers.referer"/> with an ‘https:’ scheme sent in an unsecured request</title>
    <rfc num="7231" sect="5.5.2">
      A user agent MUST NOT send a <h>Referer</h> header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.
    </rfc>
  </error>

  <comment id="1070">
    <title>Request without a <h>User-Agent</h> header</title>
    <rfc num="7231" sect="5.5.3">
      A user agent SHOULD send a <h>User-Agent</h> field in each request
   unless specifically configured not to do so.
    </rfc>
  </comment>

  <error id="1071">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.version"/> request</title>
    <rfc num="7231" sect="6.2">
      Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.
    </rfc>
  </error>

  <error id="1072">
    <title><ref to="msg.status"/> response to an <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.request.method"/> method is defined to be safe (read-only). But the <st>201</st> status code indicates that a new resource was created. Either one is wrong here.</explain>
  </error>

  <comment id="1073">
    <title>Possibly missing <h>Location</h> header</title>
    <explain>This <ref to="msg.status"/> response indicates that a new resource was created. Because there is no <h>Location</h> header in the response, it is assumed that the created resource is the same as the request target (<rfc num="7231" sect="6.3.2"/>). But <ref to="msg.request.method"/> requests are usually intended to create a sub-resource of the target resource. Therefore, it’s likely that this response needs an explicit <h>Location</h>.</explain>
  </comment>

  <error id="1074">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.request.method"/> method is defined to be safe (read-only). But the <st>202</st> status code means that the server started some kind of processing operation. Either one is wrong here.</explain>
  </error>

  <error id="1075">
    <title><ref to="msg.status"/> response with no <h>Via</h> header</title>
    <explain>The <ref to="msg.status"/> status code means that the response has been transformed by a proxy. But a proxy must also add a <h>Via</h> header to each forwarded response (<rfc num="7230" sect="5.7.1"/>), and there is no such header here.</explain>
  </error>

  <error id="1076">
    <title><ref to="msg.status"/> response with a <ref to="msg.body">payload</ref></title>
    <rfc num="7231" sect="6.3.6">
      Since the <st>205</st> status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.
    </rfc>
  </error>

  <comment id="1077">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.4.1">
      For request methods other than <m>HEAD</m>, the server SHOULD generate a
   payload in the <st>300</st> response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.
    </rfc>
  </comment>

  <comment id="1078">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.2">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a preferred URI reference for the new permanent URI.
    </rfc>
  </comment>

  <comment id="1079">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.3">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1080">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.4">
      The <st>303</st> (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the <h>Location</h> header field, which is intended to provide an
   indirect response to the original request.
    </rfc>
  </error>

  <comment id="1081">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.4.4">
      Except for responses to a <m>HEAD</m> request, the representation of a <st>303</st>
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the <h>Location</h> header field.
    </rfc>
  </comment>

  <error id="1082">
    <title>Using deprecated status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.4.5">
      The <st>305</st> (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).
    </rfc>
  </error>

  <error id="1083">
    <title>Using reserved status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.4.6">
      The <st>306</st> status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.
    </rfc>
  </error>

  <comment id="1084">
    <title><ref to="msg.status"/> response with no <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.7">
      The server SHOULD generate a <h>Location</h> header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1085">
    <title>Redirection to the same URI</title>
    <explain>This <ref to="msg.status"/> response includes a <ref to="msg.headers.location"/> header that points to the same URI as the <ref to="msg.request.target">request URI</ref>. So the resource redirects to itself.</explain>
  </error>

  <error id="1086">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.target">server-wide</ref> <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.status"/> status code means that the target resource can be found at a different URI. But this was an “<m>OPTIONS</m> *” request—it targets the entire server, not any particular resource. So the <ref to="msg.status"/> status code makes no sense here.</explain>
    <explain>Perhaps the <st>303</st> status code would fit better.</explain>
  </error>

  <comment id="1087">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1088">
    <title>Using reserved status code <ref to="msg.status"/></title>
    <rfc num="7231" sect="6.5.2">
      The <st>402</st> (Payment Required) status code is reserved for future use.
    </rfc>
  </error>

  <error id="1089">
    <title><ref to="msg.status"/> response with no <h>Allow</h> header</title>
    <rfc num="7231" sect="6.5.5">
      The origin server MUST generate an
   <h>Allow</h> header field in a <st>405</st> response containing a list of the target
   resource's currently supported methods.
    </rfc>
  </error>

  <error id="1090">
    <title>Wrong use of status code <ref to="msg.status"/></title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers, such as <h>Accept</h>. But this request has no such headers.</explain>
    <explain>See also <rfc num="7231" sect="5.3"/>.</explain>
  </error>

  <comment id="1091">
    <title>Probably wrong use of status code <ref to="msg.status"/></title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers, such as <h>Accept</h>. But this request has no such headers, unless it’s an extension header not known to HTTPolice.</explain>
    <explain>See also <rfc num="7231" sect="5.3"/>.</explain>
  </comment>

  <comment id="1092">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5.6">
      The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.
    </rfc>
  </comment>

  <comment id="1093">
    <title><ref to="msg.headers.user_agent"/> contains no actual product</title>
    <explain>This request’s <h>User-Agent</h> header contains only the name of the underlying library, which isn’t very useful for identifying the request. It might be a good idea to include the name of the actual product.</explain>
    <explain>For example: “My-Product/1.0 <ref to="library"/>”.</explain>
    <explain>Or simply “My-Product/1.0” or “My-Product”.</explain>
    <explain>See <rfc num="7231" sect="5.5.3"/>.</explain>
  </comment>

  <comment id="1094">
    <title><ref to="msg.status"/> response without “<ref to="msg.headers.connection"/>: close”</title>
    <rfc num="7231" sect="6.5.7">
      A server SHOULD send the "close" connection option
   (Section 6.1 of [RFC7230]) in the response, since <st>408</st> implies that
   the server has decided to close the connection rather than continue
   waiting.
    </rfc>
  </comment>

  <error id="1095">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <explain>The <st>409</st> status code means that the request conflicted with the current state of the resource. But a <ref to="msg.request.method"/> request is, by definition, safe (read-only): it must not affect the state in any way, so there can be no conflict. The 409 status code is probably wrong here.</explain>
  </error>

  <comment id="1096">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.5.8">
      The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.
    </rfc>
  </comment>

  <error id="1097">
    <title><ref to="msg.status"/> response to a request with <ref to="msg.request.headers.content_length"/></title>
    <explain>The <st>411</st> status code means that the server wants to see a <h>Content-Length</h> header in the request. But this request did, in fact, include a valid Content-Length of <ref to="msg.request.headers.content_length.value"/>.</explain>
  </error>

  <error id="1098">
    <title><ref to="msg.status"/> response to a request with no payload</title>
    <rfc num="7231" sect="6.5.11">
      The <st>413</st> (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.
    </rfc>
  </error>

  <error id="1099">
    <title><ref to="msg.status"/> response to a request with no payload</title>
    <rfc num="7231" sect="6.5.13">
      The <st>415</st> (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
    </rfc>
  </error>

  <error id="1100">
    <title><ref to="msg.status"/> response to a request with no <h>Expect</h></title>
    <rfc num="7231" sect="6.5.14">
      The <st>417</st> (Expectation Failed) status code indicates that the
   expectation given in the request's <h>Expect</h> header field
   (Section 5.1.1) could not be met by at least one of the inbound
   servers.
    </rfc>
  </error>

  <error id="1101">
    <title><ref to="msg.status"/> response with no <h>Upgrade</h> header</title>
    <rfc num="7231" sect="6.5.15">
      The server MUST send an Upgrade header field in a <st>426</st>
   response to indicate the required protocol(s) (Section 6.7 of
   [RFC7230]).
    </rfc>
  </error>

  <error id="1102">
    <title>Unnecessary <ref to="msg.status"/> response</title>
    <explain>In this response, the server <ref to="msg.headers.upgrade">demands</ref> that the client upgrade to <ref to="protocol"/>. But the client’s request is already offering that same upgrade in its own <ref to="msg.request.headers.upgrade"/> header. The server can just send a <st>101</st> response and switch to <ref to="protocol"/> without sending an error.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
  </error>

  <error id="1103">
    <title>Not proceeding with protocol upgrade</title>
    <explain>This response’s <ref to="msg.headers.upgrade"/> header indicates that the server is ready to upgrade to <ref to="protocol"/>. But the client’s request is already offering that same upgrade in its own <ref to="msg.request.headers.upgrade"/> header. If the server actually wants to switch to <ref to="protocol"/>, it should go ahead, send a <st>101</st> response, and switch.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
  </error>

  <comment id="1104">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.6">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1105">
    <title><ref to="msg.status"/> response with the same version as the request</title>
    <explain>The <st>505</st> status code means that the server does not support the HTTP version used in the request—which is <ref to="msg.request.version"/>—but the response itself <ref to="msg.version">is</ref> of that same version.</explain>
    <rfc num="7230" sect="2.6">
      A server MUST NOT send
   a version to which it is not conformant.
    </rfc>
  </error>

  <comment id="1106">
    <title><ref to="msg.status"/> response with no payload</title>
    <rfc num="7231" sect="6.6.6">
      The server SHOULD
   generate a representation for the <st>505</st> response that describes why
   that version is not supported and what other protocols are supported
   by that server.
    </rfc>
  </comment>

  <error id="1107">
    <title>Obsolete date format in <ref to="place"/></title>
    <rfc num="7231" sect="7.1.1.1">
      When a sender generates a
   header field that contains one or more timestamps defined as
   HTTP-date, the sender MUST generate those timestamps in the
   IMF-fixdate format.
    </rfc>
  </error>

  <error id="1108">
    <title>Wrong day of week in <ref to="place"/></title>
    <explain>This message’s <ref to="place"/> claims that <ref to="date"/> is <ref to="claimed"/>, but in reality it’s <ref to="actual"/>.</explain>
  </error>

  <error id="1109">
    <title><ref to="msg.headers.date"/> header is in the future</title>
    <explain>The <h>Date</h> header contains the date and time at which the message was originated, but in this message it appears to be in the future.</explain>
    <explain>This might be due to wrong timezone settings.</explain>
  </error>

  <comment id="1110">
    <title><ref to="msg.status"/> response with no <h>Date</h> header</title>
    <explain>According to <rfc num="7231" sect="7.1.1.2"/>, any <ref to="msg.status"/> response must include a <h>Date</h> header, unless the server has no usable clock.</explain>
  </comment>

  <error id="1111">
    <title><ref to="msg.headers.location"/> with a fragment (#) in a <ref to="msg.status"/> response</title>
    <rfc num="7231" sect="7.1.2">
      There are circumstances in which a fragment identifier in a <h>Location</h>
   value would not be appropriate.  For example, the Location header
   field in a <st>201</st> (Created) response is supposed to provide a URI that
   is specific to the created resource.
    </rfc>
  </error>

  <comment id="1112">
    <title><ref to="msg.headers.location"/> header in a <ref to="msg.status"/> response</title>
    <explain><rfc num="7231" sect="7.1.2"/> does not define what it means for a <ref to="msg.status"/> response to have a <ref to="msg.headers.location"/> header. Of course, other documents (unknown to HTTPolice) may do so.</explain>
  </comment>

  <comment id="1113">
    <title><ref to="msg.headers.retry_after"/> header in a <ref to="msg.status"/> response</title>
    <explain><rfc num="7231"/> defines the meaning of the <h>Retry-After</h> header for status codes 3xx, <st>413</st> and <st>503</st>, but not for <ref to="msg.status"/>. Other documents (unknown to HTTPolice) may add such meaning, though.</explain>
  </comment>

  <error id="1114">
    <title><ref to="msg.headers.allow"/> actually includes <ref to="msg.request.method"/></title>
    <explain>The <ref to="msg.status"/> status code means that the request method, which is <ref to="msg.request.method"/>, is not allowed for this resource. But the response’s <h>Allow</h> header does include <ref to="msg.request.method"/>. Either the status code or the <h>Allow</h> header is wrong here.</explain>
  </error>

  <error id="1115">
    <title><ref to="msg.headers.allow"/> does not include <ref to="msg.request.method"/></title>
    <explain>The <ref to="msg.status"/> status code means that this <ref to="msg.request.method"/> request was handled successfully. But, according to the <h>Allow</h> header, it should have been disallowed (status code <st>405</st>). Either the status code or the <h>Allow</h> header is wrong here.</explain>
  </error>

  <error id="1116">
    <title><ref to="msg.headers.accept_encoding"/> contains <ref to="coding"/> with a quality value</title>
    <rfc num="7231" sect="5.3.4">
      Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with <cc>x-gzip</cc> or <cc>x-compress</cc>.
    </rfc>
  </error>

  <comment id="1117">
    <title><ref to="msg.status"/> response when unable to satisfy <ref to="msg.request.headers.accept_language"/></title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers. The only such header (known to HTTPolice) in this request is <h>Accept-Language</h>. However, <rfc num="7231" sect="5.3.5"/> discourages sending a <st>406</st> response in this case: it’s better to send a representation in a different language, because the user may still be able to understand some of it.</explain>
  </comment>

  <error id="1118">
    <title><ref to="msg.headers.last_modified"/> later than <ref to="msg.headers.date"/></title>
    <rfc num="7232" sect="2.2.1">
      An origin server with a clock MUST NOT send a <h>Last-Modified</h> date that
   is later than the server's time of message origination (<h>Date</h>).
    </rfc>
  </error>

  <comment id="1119">
    <title>Backslash in <ref to="place"/></title>
    <rfc num="7232" sect="2.3">
      Previously, opaque-tag was defined to be a quoted-string
      ([RFC2616], Section 3.11); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.
    </rfc>
  </comment>

  <error id="1120">
    <title>Weak entity tag in <ref to="msg.headers.if_match"/></title>
    <rfc num="7232" sect="3.1">
      An origin server MUST use the strong comparison function when
   comparing entity-tags for <h>If-Match</h> (Section 2.3.2), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.
    </rfc>
    <explain>In other words, a conformant server will never consider two weak entity tags as equal for purposes of the <h>If-Match</h> header.</explain>
  </error>

  <error id="1121">
    <title><ref to="msg.request.headers.if_none_match"/> was ignored</title>
    <explain>This is a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request, but its <ref to="msg.headers.etag"/> header matches the <h>If-None-Match</h> header of the request. The server is supposed to send a <st>304</st> response in this situation. See <rfc num="7232" sect="3.2"/>.</explain>
  </error>

  <error id="1122">
    <title><ref to="msg.headers.if_modified_since"/> in a <ref to="msg.method"/> request</title>
    <rfc num="7232" sect="3.3">
      A recipient MUST ignore the <h>If-Modified-Since</h> header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither <m>GET</m> nor <m>HEAD</m>.
    </rfc>
  </error>

  <comment id="1123">
    <title><ref to="msg.request.headers.if_modified_since"/> was ignored</title>
    <explain>This is a <ref to="msg.status"/> response to a <ref to="msg.request.method"/> request, but its <ref to="msg.headers.last_modified"/> date is no later than the <h>If-Modified-Since</h> header of the request. The server should send a <st>304</st> response in this situation. See <rfc num="7232" sect="3.3"/>.</explain>
  </comment>

  <error id="1124">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <explain>The <st>304</st> status code is only defined by <rfc num="7232" sect="4.1"/> for responses to <m>GET</m> and <m>HEAD</m> requests. With other methods, the <st>412</st> status code may be useful.</explain>
  </error>

  <error id="1125">
    <title>Wrong use of status code <ref to="msg.status"/></title>
    <explain>The <ref to="msg.status"/> status code is only used when the request includes a precondition, such as <h>If-Modified-Since</h>. There are no such preconditions in this request.</explain>
    <explain>See <rfc num="7232"/>.</explain>
  </error>

  <comment id="1126">
    <title>Probably wrong use of status code <ref to="msg.status"/></title>
    <explain>The <ref to="msg.status"/> status code is only used when the request includes a precondition, such as <h>If-Modified-Since</h>. There are no such preconditions in this request, unless it’s an extension header unknown to HTTPolice.</explain>
    <explain>See <rfc num="7232"/>.</explain>
  </comment>

  <comment id="1127">
    <title><ref to="header"/> in a <ref to="msg.status"/> response</title>
    <rfc num="7232" sect="4.1">
      Since the goal of a <st>304</st> response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., <h>Last-Modified</h> might be useful if the
   response does not have an <h>ETag</h> field).
    </rfc>
  </comment>

  <error id="1128">
    <title><ref to="msg.request.headers.if_modified_since"/> was not ignored</title>
    <explain>The <ref to="msg.status"/> status code means that the server could not satisfy a precondition included in the request. The only such precondition (known to HTTPolice) in this request is <ref to="msg.request.headers.if_modified_since"/>. But <rfc num="7232" sect="3.3"/> says that an <h>If-Modified-Since</h> header in a <ref to="msg.request.method"/> request must be ignored.</explain>
  </error>

  <error id="1129">
    <title>Wrong <ref to="msg.status"/> response</title>
    <explain>The <ref to="msg.status"/> status code means that the server could not satisfy a precondition included in the request. But, as defined in <rfc num="7232" sect="5"/>, such preconditions must be ignored in a <ref to="msg.request.method"/> request.</explain>
  </error>

  <error id="1130">
    <title><ref to="header"/> header in a <ref to="msg.method"/> request</title>
    <rfc num="7232" sect="5">
      Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as <m>CONNECT</m>, <m>OPTIONS</m>, or <m>TRACE</m>.
    </rfc>
  </error>

  <comment id="1131">
    <title><ref to="header"/> header in a <ref to="msg.method"/> request</title>
    <rfc num="7232" sect="5">
      Although conditional request header fields are defined as being
   usable with the <m>HEAD</m> method (to keep HEAD's semantics consistent with
   those of <m>GET</m>), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a <st>304</st> (Not
   Modified) response and more useful than a <st>412</st> (Precondition Failed)
   response.
    </rfc>
  </comment>

  <error id="1132">
    <title><ref to="msg.headers.range"/> header in a <ref to="msg.method"/> request</title>
    <rfc num="7233" sect="3.1">
      A server
   MUST ignore a <h>Range</h> header field received with a request method other
   than <m>GET</m>.
    </rfc>
  </error>

  <error id="1133">
    <title>Malformed byte range in <ref to="place"/></title>
    <rfc num="7233" sect="2.1">
      A byte-range-spec is invalid if the last-byte-pos value is present
   and less than the first-byte-pos.
    </rfc>
  </error>

  <error id="1134">
    <title><ref to="msg.headers.if_range"/> header without a <h>Range</h> header</title>
    <rfc num="7233" sect="3.2">
      A client MUST NOT generate an <h>If-Range</h> header field in a request that
   does not contain a <h>Range</h> header field.
    </rfc>
  </error>

  <error id="1135">
    <title>Weak entity tag in the <ref to="msg.headers.if_range"/> header</title>
    <rfc num="7233" sect="3.2">
      A client MUST NOT generate an <h>If-Range</h> header field containing an
   entity-tag that is marked as weak.
    </rfc>
  </error>

  <error id="1136">
    <title><ref to="msg.status"/> response to a request with no <h>Range</h> header</title>
    <explain>The <st>206</st> status code only makes sense in responses to partial requests—that is, requests containing a <h>Range</h> header. See <rfc num="7233" sect="4.1"/>.</explain>
  </error>

  <error id="1137">
    <title><ref to="msg.status"/> response to a <ref to="msg.request.method"/> request</title>
    <rfc num="7233" sect="3.1">
      A server
   MUST ignore a <ref to="msg.request.headers.range"/> header field received with a request method other
   than <m>GET</m>.
    </rfc>
  </error>

  <error id="1138">
    <title><ref to="msg.status"/> response with no range specifiers</title>
    <explain>The <st>206</st> status code means that the response contains one or more parts of the data. When it contains one part, the response must have a <h>Content-Range</h> header. When it contains several parts, the response must have a <ref to="msg.headers.content_type"/> of <media>multipart/byteranges</media>. This response has neither.</explain>
    <explain>See <rfc num="7233" sect="4.1"/>.</explain>
  </error>

  <error id="1139">
    <title>Multipart boundary not declared</title>
    <explain>According to the <ref to="msg.headers.content_type"/> header, this message contains a multipart payload, but the Content-Type has no ‘boundary’ parameter that is required for parsing such payload.</explain>
    <explain>See <rfc num="2046" sect="5.1.1"/>.</explain>
  </error>

  <error id="1140">
    <title>Multipart boundary not found</title>
    <explain>The multipart boundary declared in this message’s <ref to="msg.headers.content_type"/> header was not found in the <ref to="msg.body">payload body</ref>.</explain>
    <explain>See <rfc num="2046" sect="5.1.1"/>.</explain>
  </error>

  <error id="1141">
    <title>No <h>Content-Range</h> in part #<ref to="part_num"/></title>
    <rfc num="7233" sect="4.1">
      Within the header area of each body part in the <ref to="msg.headers.content_type">multipart</ref> <ref to="msg.body">payload</ref>,
   the server MUST generate a <h>Content-Range</h> header field corresponding
   to the range being enclosed in that body part.
    </rfc>
  </error>

  <comment id="1142">
    <title>No <h>Content-Type</h> in part #<ref to="part_num"/></title>
    <rfc num="7233" sect="4.1">
      If the selected
   representation would have had a <h>Content-Type</h> header field in a <st>200</st>
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each <ref to="msg.body">body</ref> <ref to="msg.headers.content_type">part</ref>.
    </rfc>
  </comment>

  <error id="1143">
    <title><ref to="msg.headers.content_range"/> header in a <ref to="msg.headers.content_type"><media>multipart/byteranges</media></ref> response</title>
    <rfc num="7233" sect="4.1">
      To avoid confusion with single-part responses, a server MUST NOT
   generate a <h>Content-Range</h> header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead).
    </rfc>
  </error>

  <error id="1144">
    <title><ref to="msg.headers.content_type"><media>multipart/byteranges</media></ref> response to a request for a single <ref to="msg.request.headers.range"/></title>
    <rfc num="7233" sect="4.1">
      A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.
    </rfc>
  </error>

  <error id="1145">
    <title>Wrong <ref to="msg.status"/> response</title>
    <explain>The request’s <ref to="msg.request.headers.if_range"/> header means that the server is expected to send a <st>206</st> response only if the representation’s <ref to="msg.headers.etag"/> matches the one specified in If-Range. In this case, it doesn’t, so the server is supposed to send a <st>200</st> response with the complete data.</explain>
    <explain>See <rfc num="7233" sect="3.2"/>.</explain>
  </error>

  <comment id="1146">
    <title>Unnecessary <ref to="header"/> in a <ref to="msg.status"/> response</title>
    <rfc num="7233" sect="4.1">
      If a <st>206</st> is generated in response to a request with an <ref to="msg.request.headers.if_range"/>
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.
    </rfc>
  </comment>

  <comment id="1147">
    <title><ref to="msg.headers.content_range"/> header in a <ref to="msg.status"/> response</title>
    <explain>The <h>Content-Range</h> header is defined by <rfc num="7233" sect="4.2"/> for responses with status codes <st>206</st> and <st>416</st>, but not <ref to="msg.status"/>.</explain>
  </comment>

  <error id="1148">
    <title>Malformed byte range in <ref to="place"/></title>
    <rfc num="7233" sect="4.2">
      A <h>Content-Range</h> field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.
    </rfc>
  </error>

  <error id="1149">
    <title><ref to="msg.status"/> response to a request with no <h>Range</h></title>
    <explain>The <st>416</st> status code is defined by <rfc num="7233" sect="4.4"/> only for responses to requests containing a <h>Range</h> header.</explain>
  </error>

  <comment id="1150">
    <title><ref to="msg.status"/> response with no <h>Content-Range</h> header</title>
    <rfc num="7233" sect="4.4">
      When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a <h>Content-Range</h> header field specifying the current
   length of the selected representation (Section 4.2).
    </rfc>
  </comment>

  <error id="1151">
    <title>Empty list element in <ref to="place"/></title>
    <rfc num="7230" sect="7">
      In any production that uses the list construct, a sender MUST NOT
   generate empty list elements.
    </rfc>
  </error>

  <error id="1152">
    <title><ref to="directive"/> cache directive in a request</title>
    <explain>This request’s <ref to="msg.headers.cache_control"/> header includes the <ref to="directive"/> directive, which defined for responses, but not for requests.</explain>
  </error>

  <error id="1153">
    <title><ref to="directive"/> cache directive in a response</title>
    <explain>This response’s <ref to="msg.headers.cache_control"/> header includes the <ref to="directive"/> directive, which is defined for requests, but not for responses.</explain>
  </error>

  <comment id="1154">
    <title>Unquoted argument to the <ref to="directive"/> cache directive</title>
    <explain>The specification for the <ref to="directive"/> directive recommends that its argument be wrapped in double quotes. But in this message’s <ref to="entry"/> header, it was not quoted.</explain>
  </comment>

  <comment id="1155">
    <title>Quoted argument to the <ref to="directive"/> cache directive</title>
    <explain>In this message’s <ref to="entry"/> header, the argument to the <ref to="directive"/> directive is wrapped in double quotes. But the specification for <ref to="directive"/> recommends that it be written as a plain token, without quotes.</explain>
  </comment>

  <error id="1156">
    <title><ref to="directive"/> cache directive with no argument</title>
    <explain>According to the specification, the <ref to="directive"/> directive must have an argument. But in this message’s <ref to="entry"/> header, it has no argument.</explain>
  </error>

  <error id="1157">
    <title><ref to="directive"/> cache directive with an argument</title>
    <explain>In this message’s <ref to="entry"/> header, the <ref to="directive"/> directive has an argument. But the specification for <ref to="directive"/> defines no argument.</explain>
  </error>

  <error id="1158">
    <title>Malformed <ref to="directive"/> cache directive</title>
    <explain>When parsing the argument to the <ref to="directive"/> directive in this message’s <ref to="entry"/> header, the following error occurred:</explain>
    <explain><ref to="error"/></explain>
  </error>

  <error id="1159">
    <title><ref to="directive"/> cache directive with an argument</title>
    <explain>In this request’s <ref to="msg.headers.cache_control"/> header, the <cache>no-cache</cache> directive has an argument. But the specification for <cache>no-cache</cache> only defines an argument when used in responses.</explain>
  </error>

  <error id="1160">
    <title>Using extension pragma ‘<ref to="pragma"/>’</title>
    <explain>This message’s <ref to="place"/> header contains a ‘<ref to="pragma"/>’ extension pragma. Extension pragmas (that is, pragma directives other than ‘no-cache’) are deprecated in <rfc num="7234" sect="5.4"/>.</explain>
  </error>

  <comment id="1161">
    <title>“<ref to="msg.headers.cache_control"/>: <cache>no-cache</cache>” without “<ref to="msg.headers.pragma"/>: no-cache”</title>
    <rfc num="7234" sect="5.4">
      When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless <h>Cache-Control</h>: <cache>no-cache</cache>
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.
    </rfc>
  </comment>

  <comment id="1162">
    <title>Response with <ref to="msg.headers.pragma"/>: no-cache</title>
    <explain>This response contains the ‘no-cache’ pragma directive, which is defined by <rfc num="7234" sect="5.4"/> for requests, but not for responses.</explain>
    <!-- Not an error because very widespread and benign. -->
  </comment>

  <comment id="1163">
    <title>Strange warn code <ref to="code"/></title>
    <explain><rfc num="7234" sect="5.5"/> defines two classes of warn codes—1xx and 2xx—but this message’s <ref to="msg.headers.warning"/> header contains a <ref to="code"/> warn code.</explain>
  </comment>

  <comment id="1164">
    <title>Warning date does not match the <ref to="msg.headers.date"/> header</title>
    <explain>This message’s <ref to="msg.headers.warning"/> header contains a warning (code <ref to="code"/>) with a date that is different from the <h>Date</h> header.</explain>
    <rfc num="7234" sect="5.5">
      If a recipient that uses, evaluates, or displays <h>Warning</h> header
   fields receives a warn-date that is different from the <h>Date</h> value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.
    </rfc>
    <!-- This probably cannot be considered an error in the response itself, as the retaining behavior would be natural for an HTTP/1.0 cache oblivious to the semantics of the warning. We could look for a 1.0 entry in the Via header, but that's too complicated for such a useless check. -->
  </comment>

  <error id="1165">
    <title>Warn code <ref to="code"/> in a request</title>
    <explain>This request’s <ref to="msg.headers.warning"/> header contains the <ref to="code"/> warn code. But, according to <rfc num="7234" sect="5.5"/>, 1xx warn codes can only be applied to responses.</explain>
  </error>

  <error id="1166">
    <title>Response from cache with no <h>Age</h> header</title>
    <explain>According to <rfc num="7234" sect="4"/>, a cache must add an <h>Age</h> header to every response that it serves without contacting the origin server. But this response has no such header.</explain>
  </error>

  <error id="1167">
    <title>Bad status code <ref to="msg.status"/></title>
    <explain>According to <rfc num="7231" sect="6"/>, HTTP status codes can only range from 100 to 599.</explain>
  </error>

  <debug id="1168">
    <title>Response from cache</title>
    <explain>The presence of the <ref to="msg.headers.age"/> header in this response implies that it was served from a cache, without contacting the origin server.</explain>
  </debug>

  <debug id="1169">
    <title>Response from cache</title>
    <explain>The <ref to="code"/> warn code in this response’s <ref to="msg.headers.warning"/> header implies that it was served from a cache, without contacting the origin server. See <rfc num="7234" sect="5.5"/>.</explain>
  </debug>

  <comment id="1170">
    <title>Response from cache older than <cache>max-age</cache></title>
    <explain>This response’s <ref to="msg.headers.age"/> of <ref to="msg.headers.age.value"/> is greater than the <cache>max-age</cache> of <ref to="msg.request.headers.cache_control.max_age"/> requested by the client’s <ref to="msg.request.headers.cache_control"/> header.</explain>
  </comment>

  <comment id="1171">
    <title><ref to="msg.method"/> request with <ref to="msg.headers.cache_control"/>: <ref to="directive"/></title>
    <explain>The <ref to="msg.method"/> method is defined as non-cacheable, so the <ref to="directive"/> directive in this request’s <h>Cache-Control</h> header  makes no difference.</explain>
  </comment>

  <error id="1172">
    <title>Response from cache to a <ref to="msg.request.method"/> request</title>
    <explain>The <ref to="msg.request.method"/> method is defined as non-cacheable.</explain>
  </error>

  <error id="1173">
    <title>Response from cache to a request with <ref to="msg.request.headers.cache_control"/>: <cache>no-cache</cache></title>
    <rfc num="7234" sect="5.2.1.4">
      The "no-cache" request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.
    </rfc>
  </error>

  <error id="1174">
    <title>Response from cache to a request with <ref to="msg.request.headers.pragma"/>: no-cache</title>
    <rfc num="7234" sect="5.4">
      When the <h>Cache-Control</h> header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if "<h>Cache-Control</h>: <cache>no-cache</cache>" were present (see
   Section 5.2.1).
    </rfc>
    <rfc num="7234" sect="5.2.1.4">
      The "no-cache" request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.
    </rfc>
  </error>

  <error id="1175">
    <title>Response from cache with <ref to="msg.headers.cache_control"/>: <cache>no-cache</cache></title>
    <rfc num="7234" sect="5.2.2.2">
      The "no-cache" response directive indicates that the response MUST
   NOT be used to satisfy a subsequent request without successful
   validation on the origin server.
    </rfc>
  </error>

  <error id="1176">
    <title>Response from cache with <ref to="msg.headers.cache_control"/>: <cache>no-store</cache></title>
    <explain>According to <rfc num="7234" sect="3"/>, a cache cannot store a response that includes the <cache>no-store</cache> directive in its <h>Cache-Control</h> header.</explain>
  </error>

  <error id="1177">
    <title>Non-cacheable <ref to="msg.status"/> response served from cache</title>
    <explain>The <ref to="msg.status"/> status code is not defined as cacheable by default. According to <rfc num="7234" sect="3"/>, such a response can only be cached if it explicitly allows caching with headers such as <h>Expires</h>. But this response has no such headers, so it is not cacheable.</explain>
  </error>

</notices>
